const pg = require('pg');
const QueryStream = require('pg-query-stream');

const connectionString = (process.argv[2] === 'local') ? 'postgres://localhost:5432/coleelam' : process.env.DATABASE_URL;

const Sequelize = require('sequelize');
const bcrypt = require('bcrypt');

console.log(connectionString);
var sequelize = new Sequelize({connectionString: connectionString, ssl: true, dialect: 'postgres'});
// console.log(sequelize);

var User = sequelize.define('users', {
  user_id: {
    type: Sequelize.INTEGER,
    unique: true,
    primaryKey: true,
    allowNull: false,
  },
  username: {
    type: Sequelize.STRING,
    unique: true,
    allowNull: false,
  },
  email: {
    type: Sequelize.STRING,
    allowNull: false,
  },
  pass_hash: {
    type: Sequelize.STRING,
    allowNull: false
  }
},
{
  indexes: [
    {
      unique: true,
      fields: ['username', 'email']
    }
  ],
  hooks: {
    beforeCreate: (user) => {
      const salt = bcrypt.genSaltSync();
      user.password = bcrypt.hashSync(user.password, salt);
    }
  },
  instanceMethods: {
    validPassword: function(password) {
      return bcrypt.compareSync(password, this.password);
    }
  }
});
var Group = sequelize.define('groups', {
  group_id: {
    type: Sequelize.INTEGER,
    unique: true,
    primaryKey: true,
    allowNull: false,
  },
  group_name: {
    type: Sequelize.STRING,
    unique: true,
    allowNull: false,
  },
  created_by: {
    type: Sequelize.INTEGER,
    references: {
      model: User,
      key: 'user_id',
      deferrable: Sequelize.Deferrable.INITIALLY_IMMEDIATE,
    },
    allowNull: false,
  },
  group_members: {
    type: Sequelize.ARRAY(Sequelize.INTEGER),
    allowNull: true,
    defaultValue: [],
  },
}, {
  hooks: {
    afterCreate: (group) => {
      group.group_members.push(group.created_by);
    }
  }
});
var _Event = sequelize.define('events', {
  event_id: {
    type: Sequelize.INTEGER,
    unique: true,
    primaryKey: true,
    allowNull: false,
  },
  event_name: {
    type: Sequelize.STRING,
    allowNull: false,
  },
  creator: {
    type: Sequelize.INTEGER,
    allowNull: false,
    references: {
      model: User,
      key: 'user_id',
      deferrable: Sequelize.Deferrable.INITIALLY_IMMEDIATE,
    },
  },
  group_id: {
    type: Sequelize.INTEGER,
    allowNull: true,
    defaultValue: null,
    references: {
      model: Group,
      key: 'group_id',
      deferrable: Sequelize.Deferrable.INITIALLY_IMMEDIATE,
    },
  },
  created_at: {
    type: Sequelize.DATE,
    defaultValue: Sequelize.NOW,
    allowNull: false,
  },
  event_time: {
    type: Sequelize.DATE,
    allowNull: false,
  },
  attendees: {
    type: Sequelize.ARRAY(Sequelize.INTEGER),
    allowNull: true,
    defaultValue: [],
  },
}, {
  indexes: [
    {
      unique: true,
      fields: ['event_name', 'creator']
    }
  ],
});

User.sync({force: true})
  .then(() => {
    console.log('\'users\' table successfully recreated.');
    Group.sync({force: true})
      .then(() => {
        console.log('\'groups\' table successfully recreated.');
        _Event.sync({force: true})
          .then(() => {
            console.log('\'events\' table successfully recreated.');
            sequelize.close()
              .then(() => {console.log('ending session')})
              .catch(err => {console.log('could not end session: ' + err)});
          })
          .catch(err => console.log('cannot recreate table events ' + err));
      })
      .catch(err => console.log('cannot recreate table groups ' + err));
  })
  .catch(error => console.log('cannot recreate tables users ' + error));
// console.log(connectionString);
// const pool = new pg.Pool({
//   connectionString: connectionString,
//   ssl: (process.argv[2] === 'local') ? false : true,
// });
// pool.query('DROP TABLE IF EXISTS users', function(err) {
//   pool.query("CREATE TABLE users (user_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, " +
//   "username text NOT NULL CHECK (username <> \'\') CONSTRAINT unique_user UNIQUE, " +
//   "email text NOT NULL CHECK (email <> \'\'), pass_hash text NOT NULL, " +
//   "CONSTRAINT user_email_unique UNIQUE (username, email))", function(err) {
//     if (err) {
//       console.log('cannot recreate table users ' + err);
//     }
//     pool.query('DROP TABLE IF EXISTS groups', function(err) {
//       pool.query("CREATE TABLE groups (group_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, " +
//       "group_name text NOT NULL CHECK (group_name <> \'\') CONSTRAINT unique_group UNIQUE, " +
//       "created_by int NOT NULL, " +
//       "group_members int ARRAY, CONSTRAINT group_created_by_user_id_fkey " +
//       "FOREIGN KEY (created_by) REFERENCES users (user_id) MATCH SIMPLE ON UPDATE NO ACTION " +
//       "ON DELETE NO ACTION)", function(err) {
//         if (err) {
//           console.log('cannot create table groups ' + err);
//         }
//         pool.query('DROP TABLE IF EXISTS events', function(err) {
//           pool.query("CREATE TABLE events (event_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, " +
//           "event_name text NOT NULL CHECK (event_name <> \'\'), " +
//           "creator int NOT NULL, group_id int, " +
//           "created_at timestamp WITHOUT TIME ZONE NOT NULL DEFAULT NOW(), attendees int ARRAY, " +
//           "event_time timestamp WITHOUT TIME ZONE NOT NULL CHECK (event_time > NOW()), " +
//           "CONSTRAINT event_created_by_user_id_fkey " +
//           "FOREIGN KEY (creator) REFERENCES users (user_id) MATCH SIMPLE ON UPDATE NO ACTION " +
//           "ON DELETE NO ACTION, CONSTRAINT user_cannot_make_duplicate_events UNIQUE (creator, event_name)," +
//           "CONSTRAINT event_group_id_fkey " +
//           "FOREIGN KEY (group_id) REFERENCES groups (group_id) MATCH SIMPLE ON UPDATE NO ACTION " +
//           "ON DELETE NO ACTION)", function(err) {
//             if (err) {
//               console.log('cannot create table events ' + err);
//             }
//             pool.end();
//           });
//         });
//       });
//     });
//   });
// });
